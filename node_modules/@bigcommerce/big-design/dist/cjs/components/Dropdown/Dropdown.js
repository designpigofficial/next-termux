"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dropdown = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _downshift = require("downshift");

var _react = _interopRequireWildcard(require("react"));

var _reactPopper = require("react-popper");

var _hooks = require("../../hooks");

var _Box = require("../Box");

var _List = require("../List");

var _styled = require("./styled");

var _excluded = ["autoWidth", "className", "disabled", "maxHeight", "id", "items", "placement", "positionFixed", "toggle", "style"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Dropdown = /*#__PURE__*/(0, _react.memo)(function (_ref) {
  var _ref$autoWidth = _ref.autoWidth,
      autoWidth = _ref$autoWidth === void 0 ? false : _ref$autoWidth,
      className = _ref.className,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      maxHeight = _ref.maxHeight,
      id = _ref.id,
      items = _ref.items,
      _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? 'bottom-start' : _ref$placement,
      _ref$positionFixed = _ref.positionFixed,
      positionFixed = _ref$positionFixed === void 0 ? false : _ref$positionFixed,
      toggle = _ref.toggle,
      style = _ref.style,
      props = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var dropdownUniqueId = (0, _hooks.useUniqueId)('dropdown');
  var flattenItems = (0, _react.useCallback)(function (items) {
    var isGroups = function isGroups(items) {
      return items.every(function (items) {
        return 'items' in items && !('content' in items);
      });
    };

    return isGroups(items) ? items.map(function (group) {
      return group.items;
    }).reduce(function (acum, curr) {
      return acum.concat(curr);
    }, []) : items;
  }, []); // We only need the items to pass down to Downshift, not groups

  var flattenedItems = (0, _react.useMemo)(function () {
    return flattenItems(items);
  }, [flattenItems, items]);
  var handleOnSelectedItemChange = (0, _react.useCallback)(function (_ref2) {
    var selectedItem = _ref2.selectedItem;

    // Links don't trigger an onItemClick
    if (selectedItem && selectedItem.type !== 'link' && typeof selectedItem.onItemClick === 'function') {
      // Call onItemClick with selected item
      selectedItem.onItemClick(selectedItem);
    }
  }, []);

  var _useSelect = (0, _downshift.useSelect)({
    circularNavigation: true,
    defaultHighlightedIndex: 0,
    id: dropdownUniqueId,
    itemToString: function itemToString(item) {
      return item ? item.content : '';
    },
    items: flattenedItems,
    menuId: id,
    onSelectedItemChange: handleOnSelectedItemChange,
    selectedItem: null,
    // We never set a selected item
    toggleButtonId: toggle.props.id
  }),
      getItemProps = _useSelect.getItemProps,
      getMenuProps = _useSelect.getMenuProps,
      getToggleButtonProps = _useSelect.getToggleButtonProps,
      highlightedIndex = _useSelect.highlightedIndex,
      isOpen = _useSelect.isOpen; // Popper


  var referenceRef = (0, _react.useRef)(null);
  var popperRef = (0, _react.useRef)(null);

  var _usePopper = (0, _reactPopper.usePopper)(referenceRef.current, popperRef.current, {
    modifiers: [{
      name: 'eventListeners',
      options: {
        scroll: isOpen,
        resize: isOpen
      }
    }, {
      name: 'offset',
      options: {
        offset: [0, 4]
      }
    }],
    placement: placement,
    strategy: positionFixed ? 'fixed' : 'absolute'
  }),
      attributes = _usePopper.attributes,
      styles = _usePopper.styles,
      update = _usePopper.update;

  var renderToggle = (0, _react.useMemo)(function () {
    return /*#__PURE__*/(0, _react.isValidElement)(toggle) && /*#__PURE__*/(0, _react.cloneElement)(toggle, _objectSpread({}, getToggleButtonProps({
      'aria-expanded': isOpen,
      // Because of memoization, we need to manually set this option
      disabled: disabled,
      ref: referenceRef
    })));
  }, [disabled, getToggleButtonProps, isOpen, toggle]);
  return /*#__PURE__*/_react.default.createElement(_styled.StyledBox, null, renderToggle, /*#__PURE__*/_react.default.createElement(_Box.Box, (0, _extends2.default)({
    ref: popperRef,
    style: styles.popper
  }, attributes.poppper, {
    zIndex: "popover"
  }), /*#__PURE__*/_react.default.createElement(_List.List, (0, _extends2.default)({}, props, {
    autoWidth: autoWidth,
    getItemProps: getItemProps,
    getMenuProps: getMenuProps,
    highlightedIndex: highlightedIndex,
    isDropdown: true,
    isOpen: isOpen,
    items: items,
    maxHeight: maxHeight,
    update: update
  }))));
});
exports.Dropdown = Dropdown;