"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Select = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _downshift = require("downshift");

var _react = _interopRequireWildcard(require("react"));

var _reactPopper = require("react-popper");

var _hooks = require("../../hooks");

var _utils = require("../../utils");

var _Box = require("../Box");

var _Form = require("../Form");

var _Input = require("../Input");

var _List = require("../List");

var _styled = require("../Select/styled");

var _excluded = ["action", "autoComplete", "autoWidth", "className", "disabled", "filterable", "id", "inputRef", "label", "labelId", "maxHeight", "onClose", "onOpen", "onOptionChange", "options", "placeholder", "placement", "positionFixed", "required", "style", "value"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Select = (0, _utils.typedMemo)(function (_ref) {
  var action = _ref.action,
      _ref$autoComplete = _ref.autoComplete,
      autoComplete = _ref$autoComplete === void 0 ? 'off' : _ref$autoComplete,
      _ref$autoWidth = _ref.autoWidth,
      autoWidth = _ref$autoWidth === void 0 ? false : _ref$autoWidth,
      className = _ref.className,
      disabled = _ref.disabled,
      _ref$filterable = _ref.filterable,
      filterable = _ref$filterable === void 0 ? true : _ref$filterable,
      id = _ref.id,
      inputRef = _ref.inputRef,
      label = _ref.label,
      labelId = _ref.labelId,
      maxHeight = _ref.maxHeight,
      onClose = _ref.onClose,
      onOpen = _ref.onOpen,
      onOptionChange = _ref.onOptionChange,
      options = _ref.options,
      placeholder = _ref.placeholder,
      _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? 'bottom-start' : _ref$placement,
      _ref$positionFixed = _ref.positionFixed,
      positionFixed = _ref$positionFixed === void 0 ? false : _ref$positionFixed,
      required = _ref.required,
      style = _ref.style,
      value = _ref.value,
      props = (0, _objectWithoutProperties2.default)(_ref, _excluded);
  var defaultRef = /*#__PURE__*/(0, _react.createRef)();
  var selectUniqueId = (0, _hooks.useUniqueId)('select');

  var _useState = (0, _react.useState)(''),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var flattenOptions = (0, _react.useCallback)(function (options) {
    var isGroups = function isGroups(options) {
      return options.every(function (option) {
        return 'options' in option && !('value' in option);
      });
    };

    return isGroups(options) ? options.map(function (group) {
      return group.options;
    }).reduce(function (acum, curr) {
      return acum.concat(curr);
    }, []) : options;
  }, []); // We need to pass Downshift only options without groups for accessibility tracking

  var flattenedOptions = (0, _react.useMemo)(function () {
    return action ? [].concat((0, _toConsumableArray2.default)(flattenOptions(options)), [action]) : flattenOptions(options);
  }, [action, flattenOptions, options]); // Find the selected option

  var selectedOption = (0, _react.useMemo)(function () {
    return flattenedOptions.find(function (option) {
      return 'value' in option && option.value === value;
    });
  }, [flattenedOptions, value]); // Initialize with flattened options

  var _useState3 = (0, _react.useState)(flattenedOptions),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      filteredOptions = _useState4[0],
      setFilteredOptions = _useState4[1]; // Need to set select options if options prop changes


  (0, _react.useEffect)(function () {
    return setFilteredOptions(flattenedOptions);
  }, [flattenedOptions]);

  var handleOnSelectedItemChange = function handleOnSelectedItemChange(changes) {
    if (action && changes.selectedItem && changes.selectedItem.content === action.content) {
      action.onActionClick(inputValue || null);
    } else if (changes.selectedItem && 'value' in changes.selectedItem && typeof onOptionChange === 'function') {
      onOptionChange(changes.selectedItem.value, changes.selectedItem);
    }
  };

  var handleOnInputValueChange = function handleOnInputValueChange(_ref2) {
    var inputValue = _ref2.inputValue,
        isOpen = _ref2.isOpen;

    // Filter only when List is open
    if (filterable && isOpen === true) {
      setFilteredOptions(filterOptions(inputValue));
    }

    setInputValue(inputValue || '');
  };

  var filterOptions = function filterOptions() {
    var inputVal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return flattenedOptions.filter(function (option) {
      return option.content === (action && action.content) || option.content.toLowerCase().startsWith(inputVal.trim().toLowerCase());
    });
  };

  var handleOnIsOpenChange = function handleOnIsOpenChange(_ref3) {
    var isOpen = _ref3.isOpen;

    if (filterable && !isOpen) {
      // Reset the options when the List is closed
      setFilteredOptions(flattenedOptions);
    }

    if (isOpen && typeof onOpen === 'function') {
      onOpen();
    }

    if (!isOpen && typeof onClose === 'function') {
      onClose();
    }
  };

  var handleStateReducer = function handleStateReducer(_state, actionAndChanges) {
    switch (actionAndChanges.type) {
      case _downshift.useCombobox.stateChangeTypes.InputBlur:
        return _objectSpread(_objectSpread({}, actionAndChanges.changes), {}, {
          inputValue: selectedOption ? selectedOption.content : ''
        });

      default:
        return actionAndChanges.changes;
    }
  };

  var _useCombobox = (0, _downshift.useCombobox)({
    id: selectUniqueId,
    inputId: id,
    inputValue: inputValue,
    itemToString: function itemToString(item) {
      return item ? item.content : '';
    },
    items: filteredOptions,
    labelId: labelId,
    onInputValueChange: handleOnInputValueChange,
    onIsOpenChange: handleOnIsOpenChange,
    onSelectedItemChange: handleOnSelectedItemChange,
    selectedItem: selectedOption || null,
    stateReducer: handleStateReducer
  }),
      closeMenu = _useCombobox.closeMenu,
      getComboboxProps = _useCombobox.getComboboxProps,
      getInputProps = _useCombobox.getInputProps,
      getItemProps = _useCombobox.getItemProps,
      getLabelProps = _useCombobox.getLabelProps,
      getMenuProps = _useCombobox.getMenuProps,
      getToggleButtonProps = _useCombobox.getToggleButtonProps,
      highlightedIndex = _useCombobox.highlightedIndex,
      isOpen = _useCombobox.isOpen,
      openMenu = _useCombobox.openMenu,
      selectedItem = _useCombobox.selectedItem; // Popper


  var referenceRef = (0, _react.useRef)(null);
  var popperRef = (0, _react.useRef)(null);

  var _usePopper = (0, _reactPopper.usePopper)(referenceRef.current, popperRef.current, {
    modifiers: [{
      name: 'eventListeners',
      options: {
        scroll: isOpen,
        resize: isOpen
      }
    }, {
      name: 'offset',
      options: {
        offset: [0, 4]
      }
    }],
    strategy: positionFixed ? 'fixed' : 'absolute',
    placement: placement
  }),
      styles = _usePopper.styles,
      attributes = _usePopper.attributes,
      update = _usePopper.update;

  var setCallbackRef = (0, _react.useCallback)(function (ref) {
    if (typeof inputRef === 'function') {
      inputRef(ref);
    }
  }, [inputRef]);
  var getInputRef = (0, _react.useCallback)(function () {
    if (inputRef && (0, _typeof2.default)(inputRef) === 'object') {
      return inputRef;
    } else if (typeof inputRef === 'function') {
      return setCallbackRef;
    }

    return defaultRef;
  }, [defaultRef, inputRef, setCallbackRef]);
  var renderLabel = (0, _react.useMemo)(function () {
    if (!label) {
      return null;
    }

    if (typeof label === 'string') {
      return /*#__PURE__*/_react.default.createElement(_Form.FormControlLabel, (0, _extends2.default)({}, getLabelProps(), {
        renderOptional: !required
      }), label);
    }

    if ( /*#__PURE__*/(0, _react.isValidElement)(label) && label.type === _Form.FormControlLabel) {
      return /*#__PURE__*/(0, _react.cloneElement)(label, getLabelProps());
    }

    (0, _utils.warning)('label must be either a string or a FormControlLabel component.');
  }, [getLabelProps, label, required]);
  var renderToggle = (0, _react.useMemo)(function () {
    return /*#__PURE__*/_react.default.createElement(_styled.DropdownButton, (0, _extends2.default)({}, getToggleButtonProps({
      disabled: disabled,
      type: 'button'
    }), {
      "aria-label": "toggle menu",
      variant: "subtle"
    }), /*#__PURE__*/_react.default.createElement(_styled.StyledDropdownIcon, null));
  }, [disabled, getToggleButtonProps]);
  var renderInput = (0, _react.useMemo)(function () {
    return /*#__PURE__*/_react.default.createElement(_styled.StyledInputContainer, {
      ref: referenceRef
    }, /*#__PURE__*/_react.default.createElement(_Input.Input, (0, _extends2.default)({}, getInputProps(_objectSpread(_objectSpread({}, props), {}, {
      autoComplete: autoComplete,
      disabled: disabled,
      onClick: function onClick() {
        !isOpen && openMenu();
      },
      onFocus: function onFocus(event) {
        !isOpen && openMenu();

        if (typeof props.onFocus === 'function') {
          props.onFocus(event);
        }
      },
      onKeyDown: function onKeyDown(event) {
        switch (event.key) {
          case 'Enter':
            event.preventDefault();

            if (isOpen === false) {
              openMenu(); // https://github.com/downshift-js/downshift/issues/734

              event.nativeEvent.preventDownshiftDefault = true;
            }

            break;

          case 'Escape':
            if (isOpen === false) {
              // Reset the value to empty
              onOptionChange();
            } else {
              closeMenu();
            } // https://github.com/downshift-js/downshift/issues/734


            event.nativeEvent.preventDownshiftDefault = true;
            break;
        }
      },
      placeholder: placeholder,
      ref: getInputRef(),
      readOnly: !filterable,
      required: required
    })), {
      iconLeft: selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.icon,
      iconRight: renderToggle
    })));
  }, [autoComplete, closeMenu, disabled, filterable, getInputProps, getInputRef, isOpen, onOptionChange, openMenu, placeholder, props, renderToggle, required, selectedItem]);
  return /*#__PURE__*/_react.default.createElement("div", null, renderLabel, /*#__PURE__*/_react.default.createElement("div", getComboboxProps(), renderInput), /*#__PURE__*/_react.default.createElement(_Box.Box, (0, _extends2.default)({
    ref: popperRef,
    style: styles.popper
  }, attributes.poppper, {
    zIndex: "popover"
  }), /*#__PURE__*/_react.default.createElement(_List.List, {
    action: action,
    autoWidth: autoWidth,
    filteredItems: filteredOptions,
    getItemProps: getItemProps,
    getMenuProps: getMenuProps,
    highlightedIndex: highlightedIndex,
    isOpen: isOpen,
    items: options,
    maxHeight: maxHeight,
    selectedItem: selectedItem && 'value' in selectedItem ? selectedItem : null,
    update: update
  })));
});
exports.Select = Select;