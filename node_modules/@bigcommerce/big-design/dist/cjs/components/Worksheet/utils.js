"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiddenRows = exports.invalidRows = exports.editedRows = exports.deleteCells = exports.mergeCells = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var mergeCells = function mergeCells(oldCells, newCells) {
  return newCells.reduce(function (accum, newCell) {
    var index = oldCells.findIndex(function (oldCell) {
      return oldCell.rowIndex === newCell.rowIndex && oldCell.columnIndex === newCell.columnIndex;
    });

    if (index > -1) {
      accum[index] = newCell;
      return accum;
    }

    return accum.concat(newCell);
  }, (0, _toConsumableArray2.default)(oldCells) // Note: returns a new array every time
  );
};

exports.mergeCells = mergeCells;

var deleteCells = function deleteCells(oldCells, newCells) {
  return oldCells.filter(function (oldCell) {
    return !newCells.find(function (newCell) {
      return newCell.columnIndex === oldCell.columnIndex && newCell.rowIndex === oldCell.rowIndex;
    });
  });
};

exports.deleteCells = deleteCells;

var editedRows = function editedRows(editedCells, rows) {
  return editedCells.reduce(function (accum, _ref) {
    var rowIndex = _ref.rowIndex;
    var row = rows[rowIndex]; // Check to see if the row already exists in accum

    if (accum.find(function (editedRow) {
      return editedRow === row;
    })) {
      return accum;
    } else {
      // Only append new rows
      return [].concat((0, _toConsumableArray2.default)(accum), [row]);
    }
  }, []);
};

exports.editedRows = editedRows;

var invalidRows = function invalidRows(invalidCells, rows) {
  var mapObj = new Map(); // Create Map with each row and append errors per row

  invalidCells.forEach(function (_ref2) {
    var rowIndex = _ref2.rowIndex,
        hash = _ref2.hash;
    var row = rows[rowIndex];

    if (mapObj.has(row)) {
      var errors = mapObj.get(row);
      mapObj.set(row, new Set([].concat((0, _toConsumableArray2.default)(errors), [hash])));
    } else {
      mapObj.set(row, new Set([hash]));
    }
  });
  return Array.from(mapObj).map(function (_ref3) {
    var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
        item = _ref4[0],
        errors = _ref4[1];

    return {
      item: item,
      errors: Array.from(errors)
    };
  });
};

exports.invalidRows = invalidRows;

var getHiddenRows = function getHiddenRows(expandableRows) {
  return Object.values(expandableRows).flat();
};

exports.getHiddenRows = getHiddenRows;