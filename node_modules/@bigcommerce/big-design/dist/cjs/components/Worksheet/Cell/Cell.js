"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cell = void 0;

var _react = _interopRequireWildcard(require("react"));

var _utils = require("../../../utils");

var _Typography = require("../../Typography");

var _editors = require("../editors");

var _hooks = require("../hooks");

var _styled = require("./styled");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var InternalCell = function InternalCell(_ref) {
  var columnIndex = _ref.columnIndex,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      formatting = _ref.formatting,
      hash = _ref.hash,
      options = _ref.options,
      rowIndex = _ref.rowIndex,
      type = _ref.type,
      rowId = _ref.rowId,
      validation = _ref.validation,
      value = _ref.value;
  var cell = (0, _react.useMemo)(function () {
    return {
      columnIndex: columnIndex,
      disabled: disabled,
      hash: hash,
      rowIndex: rowIndex,
      type: type,
      value: value
    };
  }, [columnIndex, disabled, hash, rowIndex, type, value]);

  var _useEditableCell = (0, _hooks.useEditableCell)(cell),
      handleBlur = _useEditableCell.handleBlur,
      handleChange = _useEditableCell.handleChange,
      handleDoubleClick = _useEditableCell.handleDoubleClick,
      handleKeyDown = _useEditableCell.handleKeyDown,
      isEditing = _useEditableCell.isEditing;

  var setSelectedRows = (0, _hooks.useStore)(function (state) {
    return state.setSelectedRows;
  });
  var setSelectedCells = (0, _hooks.useStore)(function (state) {
    return state.setSelectedCells;
  });
  var addInvalidCells = (0, _hooks.useStore)(function (state) {
    return state.addInvalidCells;
  });
  var removeInvalidCells = (0, _hooks.useStore)(function (state) {
    return state.removeInvalidCells;
  });
  var isSelected = (0, _hooks.useStore)((0, _react.useMemo)(function () {
    return function (state) {
      return state.selectedCells.some(function (selectedCell) {
        return selectedCell.columnIndex === cell.columnIndex && selectedCell.rowIndex === cell.rowIndex;
      });
    };
  }, [cell]));
  var isEdited = (0, _hooks.useStore)((0, _react.useMemo)(function () {
    return function (state) {
      return state.editedCells.some(function (editedCell) {
        return editedCell.columnIndex === cell.columnIndex && editedCell.rowIndex === cell.rowIndex;
      });
    };
  }, [cell]));
  var invalidCell = (0, _hooks.useStore)((0, _react.useMemo)(function () {
    return function (state) {
      return state.invalidCells.find(function (invalidCell) {
        return invalidCell.columnIndex === cell.columnIndex && invalidCell.rowIndex === cell.rowIndex;
      });
    };
  }, [cell.columnIndex, cell.rowIndex]));
  var isValid = (0, _react.useMemo)(function () {
    return typeof validation === 'function' ? validation(value) : true;
  }, [validation, value]);
  (0, _react.useEffect)(function () {
    // Remove from invalidCells if new value is valid
    if (isValid && invalidCell) {
      removeInvalidCells([cell]);
    } // Add to invalidCells but only if value is different


    if (!isValid && (!invalidCell || invalidCell.value !== cell.value)) {
      addInvalidCells([cell]);
    }
  }, [addInvalidCells, cell, isValid, invalidCell, removeInvalidCells]);
  var handleClick = (0, _react.useCallback)(function () {
    setSelectedRows([rowIndex]);
    setSelectedCells([cell]);
  }, [cell, rowIndex, setSelectedCells, setSelectedRows]);
  var renderedValue = (0, _react.useMemo)(function () {
    if (value !== 'undefined' && value !== '' && !Number.isNaN(value)) {
      if (typeof formatting === 'function') {
        return formatting(value);
      }

      return "".concat(value);
    }

    if (Number.isNaN(value)) {
      return "".concat(value);
    }

    return '';
  }, [formatting, value]);
  var renderedCell = (0, _react.useMemo)(function () {
    switch (type) {
      case 'select':
        return /*#__PURE__*/_react.default.createElement(_editors.SelectEditor, {
          cell: cell,
          isEditing: isEditing,
          onBlur: handleBlur,
          onChange: handleChange,
          options: options
        });

      case 'checkbox':
        return /*#__PURE__*/_react.default.createElement(_editors.CheckboxEditor, {
          cell: cell,
          toggle: isEditing,
          onBlur: handleBlur,
          onChange: handleChange
        });

      case 'modal':
        return /*#__PURE__*/_react.default.createElement(_editors.ModalEditor, {
          cell: cell,
          formatting: formatting,
          isEditing: isEditing
        });

      case 'toggle':
        return /*#__PURE__*/_react.default.createElement(_editors.ToggleEditor, {
          rowId: rowId,
          toggle: isEditing
        });

      default:
        return isEditing && !disabled ? /*#__PURE__*/_react.default.createElement(_editors.TextEditor, {
          cell: cell,
          isEdited: isEdited,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown
        }) : /*#__PURE__*/_react.default.createElement(_Typography.Small, {
          color: disabled ? 'secondary50' : 'secondary70',
          ellipsis: true,
          title: renderedValue
        }, renderedValue);
    }
  }, [cell, disabled, formatting, handleBlur, handleChange, handleKeyDown, isEdited, isEditing, options, rowId, renderedValue, type]);
  return /*#__PURE__*/_react.default.createElement(_styled.StyledCell, {
    isEdited: isEdited,
    isSelected: isSelected,
    isValid: isValid,
    onClick: handleClick,
    onDoubleClick: handleDoubleClick,
    type: type
  }, renderedCell);
};

var Cell = (0, _utils.typedMemo)(InternalCell);
exports.Cell = Cell;