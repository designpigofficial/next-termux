import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { useEffect, useState } from 'react';
import { depthFirstSearch } from '../../../utils';

var getDefaultSelectedValues = function getDefaultSelectedValues(_ref) {
  var nodes = _ref.nodes,
      selectedNodes = _ref.selectedNodes,
      type = _ref.type;

  if (type === 'radio') {
    var selectedNode = depthFirstSearch(nodes, function (_ref2) {
      var id = _ref2.id,
          value = _ref2.value;
      return selectedNodes.includes(id) && value !== undefined;
    });

    if (selectedNode && selectedNode.value !== undefined) {
      return [selectedNode.value];
    }
  }

  if (type === 'multi') {
    var _depthFirstSearch$red, _depthFirstSearch;

    return (_depthFirstSearch$red = (_depthFirstSearch = depthFirstSearch(nodes, function (_ref3) {
      var id = _ref3.id,
          value = _ref3.value;
      return selectedNodes.includes(id) && value !== undefined;
    }, false)) === null || _depthFirstSearch === void 0 ? void 0 : _depthFirstSearch.reduce(function (acc, node) {
      return node.value !== undefined ? [].concat(_toConsumableArray(acc), [node.value]) : acc;
    }, [])) !== null && _depthFirstSearch$red !== void 0 ? _depthFirstSearch$red : [];
  }

  return [];
};

export var useSelectable = function useSelectable(_ref4) {
  var defaultSelected = _ref4.defaultSelected,
      disabledNodes = _ref4.disabledNodes,
      nodes = _ref4.nodes,
      onSelectionChange = _ref4.onSelectionChange,
      type = _ref4.type;

  var _useState = useState(defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : []),
      _useState2 = _slicedToArray(_useState, 2),
      selectedNodes = _useState2[0],
      setSelectedNodes = _useState2[1];

  var _useState3 = useState(function () {
    return type ? getDefaultSelectedValues({
      nodes: nodes,
      selectedNodes: selectedNodes,
      type: type
    }) : [];
  }),
      _useState4 = _slicedToArray(_useState3, 2),
      selectedValues = _useState4[0],
      setSelectedValues = _useState4[1];

  useEffect(function () {
    if (defaultSelected) {
      setSelectedNodes(defaultSelected);
      setSelectedValues(getDefaultSelectedValues({
        nodes: nodes,
        selectedNodes: defaultSelected,
        type: type
      }));
    }
  }, [defaultSelected, nodes, type]);
  useEffect(function () {
    if (type === 'radio') {
      if (selectedNodes.length >= 1) {
        setSelectedNodes(function (prevSelected) {
          return prevSelected.splice(0, 1);
        });
        setSelectedValues(function (prevValues) {
          return prevValues.splice(0, 1);
        });
      } else {
        if (nodes.length) {
          var firstSelectedNode = depthFirstSearch(nodes, function (node) {
            return node.value !== undefined;
          }, true); // Need to check for undefined value since TS can't determine from DFS check.

          if (firstSelectedNode && firstSelectedNode.value !== undefined) {
            setSelectedNodes([firstSelectedNode.id]);
            setSelectedValues([firstSelectedNode.value]);
          }
        }
      }
    }
  }, [nodes, selectedNodes.length, setSelectedNodes, type]);
  useEffect(function () {
    if (typeof onSelectionChange === 'function') {
      onSelectionChange(selectedValues);
    }
  }, [onSelectionChange, selectedValues]);

  var onSelect = function onSelect(nodeId, value) {
    if (disabledNodes !== null && disabledNodes !== void 0 && disabledNodes.includes(nodeId)) {
      return;
    }

    if (type === 'multi') {
      if (selectedNodes.includes(nodeId)) {
        setSelectedNodes(function (prevNodes) {
          return prevNodes.filter(function (prevNodeId) {
            return prevNodeId !== nodeId;
          });
        });
        setSelectedValues(function (prevValues) {
          return prevValues.filter(function (prevValue) {
            return prevValue !== value;
          });
        });
      } else {
        setSelectedNodes([].concat(_toConsumableArray(selectedNodes), [nodeId]));
        setSelectedValues([].concat(_toConsumableArray(selectedValues), [value]));
      }
    }

    if (type === 'radio' && !selectedNodes.includes(nodeId)) {
      setSelectedNodes([nodeId]);
      setSelectedValues([value]);
    }
  };

  return {
    selectedNodes: selectedNodes,
    onSelect: onSelect
  };
};