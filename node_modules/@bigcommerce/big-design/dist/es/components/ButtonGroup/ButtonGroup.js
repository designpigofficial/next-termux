import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["iconOnly", "iconRight", "iconLeft"],
    _excluded2 = ["actions"],
    _excluded3 = ["text", "icon"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { MoreHorizIcon } from '@bigcommerce/big-design-icons';
import React, { createRef, memo, useCallback, useEffect, useMemo, useState } from 'react';
import { useWindowResizeListener } from '../../hooks';
import { Dropdown } from '../Dropdown';
import { Flex } from '../Flex';
import { StyledButton, StyledFlexItem } from './styled';

var excludeIconProps = function excludeIconProps(_ref) {
  var iconOnly = _ref.iconOnly,
      iconRight = _ref.iconRight,
      iconLeft = _ref.iconLeft,
      actionProps = _objectWithoutProperties(_ref, _excluded);

  return actionProps;
};

export var ButtonGroup = /*#__PURE__*/memo(function (_ref2) {
  var actions = _ref2.actions,
      wrapperProps = _objectWithoutProperties(_ref2, _excluded2);

  var parentRef = /*#__PURE__*/createRef();
  var dropdownRef = /*#__PURE__*/createRef();

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isMenuVisible = _useState2[0],
      setIsMenuVisible = _useState2[1];

  var _useState3 = useState([]),
      _useState4 = _slicedToArray(_useState3, 2),
      actionsState = _useState4[0],
      setActionsState = _useState4[1];

  useEffect(function () {
    setActionsState(actions.map(function (action) {
      return {
        isVisible: true,
        action: excludeIconProps(action),
        ref: /*#__PURE__*/createRef()
      };
    }));
  }, [actions]);
  var hideOverflowedActions = useCallback(function () {
    var _parentRef$current, _dropdownRef$current;

    var parentWidth = (_parentRef$current = parentRef.current) === null || _parentRef$current === void 0 ? void 0 : _parentRef$current.offsetWidth;
    var dropdownWidth = (_dropdownRef$current = dropdownRef.current) === null || _dropdownRef$current === void 0 ? void 0 : _dropdownRef$current.offsetWidth;

    if (!parentWidth || !dropdownWidth) {
      return;
    }

    var remainingWidth = parentWidth;
    var nextState = actionsState.map(function (stateObj) {
      var _stateObj$ref$current;

      var actionWidth = (_stateObj$ref$current = stateObj.ref.current) === null || _stateObj$ref$current === void 0 ? void 0 : _stateObj$ref$current.offsetWidth;

      if (!actionWidth) {
        return stateObj;
      }

      if (stateObj.action.actionType === 'destructive') {
        return _objectSpread(_objectSpread({}, stateObj), {}, {
          isVisible: false
        });
      }

      if (remainingWidth - actionWidth > dropdownWidth) {
        remainingWidth = remainingWidth - actionWidth;
        return _objectSpread(_objectSpread({}, stateObj), {}, {
          isVisible: true
        });
      }

      return _objectSpread(_objectSpread({}, stateObj), {}, {
        isVisible: false
      });
    });
    var visibleActions = actionsState.filter(function (_ref3) {
      var isVisible = _ref3.isVisible;
      return isVisible;
    });
    var nextVisibleActions = nextState.filter(function (_ref4) {
      var isVisible = _ref4.isVisible;
      return isVisible;
    });

    if (visibleActions.length !== nextVisibleActions.length) {
      setActionsState(nextState);
    }
  }, [actionsState, dropdownRef, parentRef]);
  var renderedDropdown = useMemo(function () {
    return /*#__PURE__*/React.createElement(StyledFlexItem, {
      "data-testid": "buttongroup-dropdown",
      isVisible: isMenuVisible,
      ref: dropdownRef,
      role: "listitem"
    }, /*#__PURE__*/React.createElement(Dropdown, {
      items: actionsState.filter(function (_ref5) {
        var isVisible = _ref5.isVisible;
        return !isVisible;
      }).map(function (_ref6) {
        var action = _ref6.action,
            ref = _ref6.ref;
        return {
          actionType: action.actionType,
          content: action.text,
          disabled: action.disabled,
          onItemClick: function onItemClick() {
            if (ref.current) {
              ref.current.getElementsByTagName('button')[0].click();
            }
          },
          hash: action.text.toLowerCase(),
          icon: action.icon
        };
      }),
      toggle: /*#__PURE__*/React.createElement(StyledButton, {
        borderRadius: actionsState.every(function (_ref7) {
          var isVisible = _ref7.isVisible;
          return !isVisible;
        }),
        iconOnly: /*#__PURE__*/React.createElement(MoreHorizIcon, {
          title: "more"
        }),
        variant: "secondary"
      }),
      placement: "bottom-end"
    }));
  }, [actionsState, dropdownRef, isMenuVisible]);
  var renderedActions = useMemo(function () {
    return _toConsumableArray(actionsState).reverse().sort(function (_ref8) {
      var isVisible = _ref8.isVisible;
      return isVisible ? -1 : 1;
    }).map(function (_ref9, key) {
      var action = _ref9.action,
          isVisible = _ref9.isVisible,
          ref = _ref9.ref;

      var text = action.text,
          icon = action.icon,
          buttonProps = _objectWithoutProperties(action, _excluded3);

      return /*#__PURE__*/React.createElement(StyledFlexItem, {
        "data-testid": "buttongroup-item",
        key: key,
        isVisible: isVisible,
        ref: ref,
        role: "listitem"
      }, /*#__PURE__*/React.createElement(StyledButton, _extends({}, buttonProps, {
        variant: "secondary"
      }), text));
    });
  }, [actionsState]);
  useEffect(function () {
    var nextIsMenuVisible = actionsState.some(function (_ref10) {
      var isVisible = _ref10.isVisible;
      return !isVisible;
    });

    if (nextIsMenuVisible !== isMenuVisible) {
      setIsMenuVisible(nextIsMenuVisible);
    }
  }, [actionsState, isMenuVisible]);
  useEffect(function () {
    hideOverflowedActions();
  }, [actions, parentRef, hideOverflowedActions]);
  useWindowResizeListener(function () {
    hideOverflowedActions();
  });
  return actions.length > 0 ? /*#__PURE__*/React.createElement(Flex, _extends({}, wrapperProps, {
    "data-testid": "buttongroup-wrapper",
    flexDirection: "row",
    flexWrap: "nowrap",
    ref: parentRef,
    role: "list"
  }), renderedActions, renderedDropdown) : null;
});