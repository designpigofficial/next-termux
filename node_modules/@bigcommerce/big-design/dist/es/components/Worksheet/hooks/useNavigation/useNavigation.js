import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { useCallback, useMemo } from 'react';
import { useStore } from '../useStore';
export var useNavigation = function useNavigation(selectedCell) {
  var rows = useStore(useMemo(function () {
    return function (state) {
      return state.rows;
    };
  }, []));
  var columns = useStore(useMemo(function () {
    return function (state) {
      return state.columns;
    };
  }, []));
  var hiddenRows = useStore(useMemo(function () {
    return function (state) {
      return state.hiddenRows;
    };
  }, []));
  var setSelectedCells = useStore(function (state) {
    return state.setSelectedCells;
  });
  var setSelectedRows = useStore(function (state) {
    return state.setSelectedRows;
  });
  var isValidPosition = useCallback(function (position) {
    var rowLength = rows.length;
    var columnsLength = columns.length; // Check to see if the next indexes fit inside the matrix

    return position.rowIndex >= 0 && position.rowIndex < rowLength && position.columnIndex >= 0 && position.columnIndex < columnsLength;
  }, [columns, rows]);
  var isHidden = useCallback(function (rowIndex) {
    var row = rows[rowIndex];
    var id = row.id;
    return hiddenRows.includes(id);
  }, [hiddenRows, rows]); // This function will look for the next non hidden offset,
  // depending on the direction of the offset.

  var getNextOffset = useCallback(function (_ref) {
    var columnIndex = _ref.columnIndex,
        rowIndex = _ref.rowIndex;

    if (rowIndex === 0) {
      if (columnIndex > 0) {
        return {
          columnIndex: ++columnIndex,
          rowIndex: rowIndex
        };
      }

      return {
        columnIndex: --columnIndex,
        rowIndex: rowIndex
      };
    }

    if (rowIndex > 0) {
      return {
        rowIndex: ++rowIndex,
        columnIndex: columnIndex
      };
    }

    return {
      rowIndex: --rowIndex,
      columnIndex: columnIndex
    };
  }, []);
  var navigate = useCallback(function (offset) {
    if (!selectedCell) {
      return;
    }

    var newPosition = {
      columnIndex: selectedCell.columnIndex + offset.columnIndex,
      rowIndex: selectedCell.rowIndex + offset.rowIndex
    };

    if (isValidPosition(newPosition)) {
      if (isHidden(newPosition.rowIndex)) {
        return navigate(getNextOffset(offset));
      }

      var hash = columns[newPosition.columnIndex].hash;
      var type = columns[newPosition.columnIndex].type || 'text';
      var value = rows[newPosition.rowIndex][hash];
      var disabled = columns[newPosition.columnIndex].disabled || false;

      var cell = _objectSpread(_objectSpread({}, newPosition), {}, {
        disabled: disabled,
        hash: hash,
        type: type,
        value: value
      });

      setSelectedCells([cell]);
      setSelectedRows([newPosition.rowIndex]);
    }
  }, [columns, getNextOffset, isHidden, isValidPosition, rows, selectedCell, setSelectedCells, setSelectedRows]);
  return useMemo(function () {
    return {
      navigate: navigate
    };
  }, [navigate]);
};