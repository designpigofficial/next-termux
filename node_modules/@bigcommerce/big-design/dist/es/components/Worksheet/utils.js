import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
export var mergeCells = function mergeCells(oldCells, newCells) {
  return newCells.reduce(function (accum, newCell) {
    var index = oldCells.findIndex(function (oldCell) {
      return oldCell.rowIndex === newCell.rowIndex && oldCell.columnIndex === newCell.columnIndex;
    });

    if (index > -1) {
      accum[index] = newCell;
      return accum;
    }

    return accum.concat(newCell);
  }, _toConsumableArray(oldCells) // Note: returns a new array every time
  );
};
export var deleteCells = function deleteCells(oldCells, newCells) {
  return oldCells.filter(function (oldCell) {
    return !newCells.find(function (newCell) {
      return newCell.columnIndex === oldCell.columnIndex && newCell.rowIndex === oldCell.rowIndex;
    });
  });
};
export var editedRows = function editedRows(editedCells, rows) {
  return editedCells.reduce(function (accum, _ref) {
    var rowIndex = _ref.rowIndex;
    var row = rows[rowIndex]; // Check to see if the row already exists in accum

    if (accum.find(function (editedRow) {
      return editedRow === row;
    })) {
      return accum;
    } else {
      // Only append new rows
      return [].concat(_toConsumableArray(accum), [row]);
    }
  }, []);
};
export var invalidRows = function invalidRows(invalidCells, rows) {
  var mapObj = new Map(); // Create Map with each row and append errors per row

  invalidCells.forEach(function (_ref2) {
    var rowIndex = _ref2.rowIndex,
        hash = _ref2.hash;
    var row = rows[rowIndex];

    if (mapObj.has(row)) {
      var errors = mapObj.get(row);
      mapObj.set(row, new Set([].concat(_toConsumableArray(errors), [hash])));
    } else {
      mapObj.set(row, new Set([hash]));
    }
  });
  return Array.from(mapObj).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        item = _ref4[0],
        errors = _ref4[1];

    return {
      item: item,
      errors: Array.from(errors)
    };
  });
};
export var getHiddenRows = function getHiddenRows(expandableRows) {
  return Object.values(expandableRows).flat();
};