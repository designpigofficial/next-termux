import React, { useCallback, useEffect, useMemo } from 'react';
import { typedMemo } from '../../../utils';
import { Small } from '../../Typography';
import { CheckboxEditor, ModalEditor, SelectEditor, TextEditor, ToggleEditor } from '../editors';
import { useEditableCell, useStore } from '../hooks';
import { StyledCell } from './styled';

var InternalCell = function InternalCell(_ref) {
  var columnIndex = _ref.columnIndex,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      formatting = _ref.formatting,
      hash = _ref.hash,
      options = _ref.options,
      rowIndex = _ref.rowIndex,
      type = _ref.type,
      rowId = _ref.rowId,
      validation = _ref.validation,
      value = _ref.value;
  var cell = useMemo(function () {
    return {
      columnIndex: columnIndex,
      disabled: disabled,
      hash: hash,
      rowIndex: rowIndex,
      type: type,
      value: value
    };
  }, [columnIndex, disabled, hash, rowIndex, type, value]);

  var _useEditableCell = useEditableCell(cell),
      handleBlur = _useEditableCell.handleBlur,
      handleChange = _useEditableCell.handleChange,
      handleDoubleClick = _useEditableCell.handleDoubleClick,
      handleKeyDown = _useEditableCell.handleKeyDown,
      isEditing = _useEditableCell.isEditing;

  var setSelectedRows = useStore(function (state) {
    return state.setSelectedRows;
  });
  var setSelectedCells = useStore(function (state) {
    return state.setSelectedCells;
  });
  var addInvalidCells = useStore(function (state) {
    return state.addInvalidCells;
  });
  var removeInvalidCells = useStore(function (state) {
    return state.removeInvalidCells;
  });
  var isSelected = useStore(useMemo(function () {
    return function (state) {
      return state.selectedCells.some(function (selectedCell) {
        return selectedCell.columnIndex === cell.columnIndex && selectedCell.rowIndex === cell.rowIndex;
      });
    };
  }, [cell]));
  var isEdited = useStore(useMemo(function () {
    return function (state) {
      return state.editedCells.some(function (editedCell) {
        return editedCell.columnIndex === cell.columnIndex && editedCell.rowIndex === cell.rowIndex;
      });
    };
  }, [cell]));
  var invalidCell = useStore(useMemo(function () {
    return function (state) {
      return state.invalidCells.find(function (invalidCell) {
        return invalidCell.columnIndex === cell.columnIndex && invalidCell.rowIndex === cell.rowIndex;
      });
    };
  }, [cell.columnIndex, cell.rowIndex]));
  var isValid = useMemo(function () {
    return typeof validation === 'function' ? validation(value) : true;
  }, [validation, value]);
  useEffect(function () {
    // Remove from invalidCells if new value is valid
    if (isValid && invalidCell) {
      removeInvalidCells([cell]);
    } // Add to invalidCells but only if value is different


    if (!isValid && (!invalidCell || invalidCell.value !== cell.value)) {
      addInvalidCells([cell]);
    }
  }, [addInvalidCells, cell, isValid, invalidCell, removeInvalidCells]);
  var handleClick = useCallback(function () {
    setSelectedRows([rowIndex]);
    setSelectedCells([cell]);
  }, [cell, rowIndex, setSelectedCells, setSelectedRows]);
  var renderedValue = useMemo(function () {
    if (value !== 'undefined' && value !== '' && !Number.isNaN(value)) {
      if (typeof formatting === 'function') {
        return formatting(value);
      }

      return "".concat(value);
    }

    if (Number.isNaN(value)) {
      return "".concat(value);
    }

    return '';
  }, [formatting, value]);
  var renderedCell = useMemo(function () {
    switch (type) {
      case 'select':
        return /*#__PURE__*/React.createElement(SelectEditor, {
          cell: cell,
          isEditing: isEditing,
          onBlur: handleBlur,
          onChange: handleChange,
          options: options
        });

      case 'checkbox':
        return /*#__PURE__*/React.createElement(CheckboxEditor, {
          cell: cell,
          toggle: isEditing,
          onBlur: handleBlur,
          onChange: handleChange
        });

      case 'modal':
        return /*#__PURE__*/React.createElement(ModalEditor, {
          cell: cell,
          formatting: formatting,
          isEditing: isEditing
        });

      case 'toggle':
        return /*#__PURE__*/React.createElement(ToggleEditor, {
          rowId: rowId,
          toggle: isEditing
        });

      default:
        return isEditing && !disabled ? /*#__PURE__*/React.createElement(TextEditor, {
          cell: cell,
          isEdited: isEdited,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown
        }) : /*#__PURE__*/React.createElement(Small, {
          color: disabled ? 'secondary50' : 'secondary70',
          ellipsis: true,
          title: renderedValue
        }, renderedValue);
    }
  }, [cell, disabled, formatting, handleBlur, handleChange, handleKeyDown, isEdited, isEditing, options, rowId, renderedValue, type]);
  return /*#__PURE__*/React.createElement(StyledCell, {
    isEdited: isEdited,
    isSelected: isSelected,
    isValid: isValid,
    onClick: handleClick,
    onDoubleClick: handleDoubleClick,
    type: type
  }, renderedCell);
};

export var Cell = typedMemo(InternalCell);